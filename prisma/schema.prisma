generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DEV_DATABASE_URL")
  relationMode = "prisma"
}

model User {
  address      String      @unique
  swapTxs      Swap[]
  liquidityTxs Liquidity[]
  dcas         DCA[]
  orders       Order[]
}

model Token {
  address       String @id
  name          String
  symbol        String
  decimals      Int
  poolsAsToken0 Pool[] @relation("pool0")
  poolsAsToken1 Pool[] @relation("pool1")
}

model Pool {
  address       String      @id
  binStep       Int
  token0Address String
  token1Address String
  token0        Token       @relation("pool0", fields: [token0Address], references: [address], onDelete: Cascade)
  token1        Token       @relation("pool1", fields: [token1Address], references: [address], onDelete: Cascade)
  analytics     Analytics[]
  swapTxs       Swap[]
  liquidityTxs  Liquidity[]
  orders        Order[]
}

model Analytics {
  date         DateTime
  volume       Int
  fees         Int
  token0Locked String
  token1Locked String
  usdLocked    Int
  close        Float
  high         Float
  low          Float
  open         Float
  poolAddress  String
  pool         Pool     @relation(fields: [poolAddress], references: [address], onDelete: Cascade)

  @@id([poolAddress, date])
}

model Swap {
  poolAddress  String
  swapForY     Boolean
  binId        Int
  amountIn     String
  amountOut    String
  timestamp    DateTime
  txHash       String
  usdValue     Float
  userAddress  String
  indexInSlot  Int
  feesIn       String
  feesUsdValue Float
  pool         Pool     @relation(fields: [poolAddress], references: [address], onDelete: Cascade)
  user         User     @relation(fields: [userAddress], references: [address])

  @@id([txHash, indexInSlot])
  @@index([timestamp], map: "timestamp")
}

model Liquidity {
  poolAddress String
  amount0     String
  amount1     String
  timestamp   DateTime
  txHash      String
  lowerBound  Int
  upperBound  Int
  usdValue    Float
  userAddress String
  indexInSlot Int      @default(1)
  pool        Pool     @relation(fields: [poolAddress], references: [address], onDelete: Cascade)
  user        User     @relation(fields: [userAddress], references: [address])

  @@id([txHash, indexInSlot])
}

model DCA {
  id            Int            @id
  txHash        String
  userAddress   String
  status        Status
  amountEachDCA String
  endTime       DateTime
  interval      Int
  nbOfDCA       Int
  startTime     DateTime
  tokenIn       String
  tokenOut      String
  execution     DCAExecution[]
  User          User           @relation(fields: [userAddress], references: [address])
}

model DCAExecution {
  id        Int    @id @default(autoincrement())
  amountIn  String
  amountOut String
  thread    Int
  period    Int
  dCAId     Int
  blockId   String
  DCA       DCA    @relation(fields: [dCAId], references: [id], onDelete: Cascade)
}

model Order {
  id             Int             @id
  txHash         String
  poolAddress    String
  swapForY       Boolean
  amountIn       String
  amountOutMin   String
  deadline       DateTime
  userAddress    String
  status         Status
  binId          Int
  User           User            @relation(fields: [userAddress], references: [address])
  Pool           Pool            @relation(fields: [poolAddress], references: [address])
  OrderExecution OrderExecution?
}

model OrderExecution {
  id        Int    @id @default(autoincrement())
  amountIn  String
  amountOut String
  thread    Int
  period    Int
  orderId   Int    @unique
  blockId   String
  Order     Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Maker {
  address        String
  epoch          Int
  poolAddress    String
  accruedFeesX   String
  accruedFeesY   String
  accruedFeesL   String
  accruedFeesUSD Int

  @@id([address, poolAddress, epoch])
}

enum Status {
  ACTIVE
  STOPPED
  ENDED
}
