generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("BUILDNET_DATABASE_URL")
  relationMode = "prisma"
}

model User {
  address      String          @unique
  swapTxs      Swap[]
  liquidityTxs Liquidity[]
  dcas         DCA[]
  orders       Order[]
  analytics    UserAnalytics[]
}

model UserAnalytics {
  date        DateTime
  totalValue  Float
  userAddress String
  user        User           @relation(fields: [userAddress], references: [address], onDelete: Cascade)
  balances    TokenBalance[]

  @@id([userAddress, date])
  @@index([date], map: "date")
}

model TokenBalance {
  id                       Int            @id @default(autoincrement())
  tokenAddress             String
  balance                  String
  value                    Float
  userAnalytics            UserAnalytics? @relation(fields: [userAnalyticsUserAddress, userAnalyticsDate], references: [userAddress, date])
  userAnalyticsUserAddress String?
  userAnalyticsDate        DateTime?
}

model Token {
  address       String           @id
  name          String
  symbol        String
  decimals      Int
  poolsAsToken0 Pool[]           @relation("pool0")
  poolsAsToken1 Pool[]           @relation("pool1")
  poolsAsReward RewardPool[]
  analytics     TokenAnalytics[]
}

model TokenAnalytics {
  date         DateTime
  volume       Int
  fees         Float
  close        Float
  high         Float
  low          Float
  open         Float
  tokenAddress String
  token        Token    @relation(fields: [tokenAddress], references: [address], onDelete: Cascade)

  @@id([tokenAddress, date])
  @@index([date], map: "date")
}

model Pool {
  address       String       @id
  binStep       Int
  token0Address String
  token1Address String
  token0        Token        @relation("pool0", fields: [token0Address], references: [address], onDelete: Cascade)
  token1        Token        @relation("pool1", fields: [token1Address], references: [address], onDelete: Cascade)
  analytics     Analytics[]
  swapTxs       Swap[]
  liquidityTxs  Liquidity[]
  orders        Order[]
  rewardPools   RewardPool[]
}

model Analytics {
  date         DateTime
  volume       Int
  fees         Float
  token0Locked String
  token1Locked String
  usdLocked    Int
  close        Float
  high         Float
  low          Float
  open         Float
  poolAddress  String
  pool         Pool     @relation(fields: [poolAddress], references: [address], onDelete: Cascade)

  @@id([poolAddress, date])
  @@index([date], map: "date")
}

model Swap {
  poolAddress  String
  swapForY     Boolean
  binId        Int
  amountIn     String
  amountOut    String
  timestamp    DateTime
  txHash       String
  usdValue     Float
  userAddress  String
  indexInSlot  Int
  feesIn       String
  feesUsdValue Float
  pool         Pool     @relation(fields: [poolAddress], references: [address], onDelete: Cascade)
  user         User     @relation(fields: [userAddress], references: [address])

  @@id([txHash, indexInSlot])
  @@index([timestamp, poolAddress], map: "timestamp")
}

model Liquidity {
  poolAddress String
  amount0     String
  amount1     String
  timestamp   DateTime
  txHash      String
  lowerBound  Int
  upperBound  Int
  usdValue    Float
  userAddress String
  indexInSlot Int      @default(1)
  pool        Pool     @relation(fields: [poolAddress], references: [address], onDelete: Cascade)
  user        User     @relation(fields: [userAddress], references: [address])

  @@id([txHash, indexInSlot])
}

model DCA {
  id            Int            @id
  txHash        String
  userAddress   String
  status        Status
  amountEachDCA String
  endTime       DateTime
  interval      Int
  nbOfDCA       Int
  startTime     DateTime
  tokenIn       String
  tokenOut      String
  execution     DCAExecution[]
  User          User           @relation(fields: [userAddress], references: [address])
}

model DCAExecution {
  id        Int    @id @default(autoincrement())
  amountIn  String
  amountOut String
  thread    Int
  period    Int
  dCAId     Int
  blockId   String
  DCA       DCA    @relation(fields: [dCAId], references: [id], onDelete: Cascade)
}

model Order {
  id             Int             @id
  txHash         String
  poolAddress    String
  swapForY       Boolean
  amountIn       String
  amountOutMin   String
  deadline       DateTime
  userAddress    String
  status         Status
  binId          Int
  User           User            @relation(fields: [userAddress], references: [address])
  Pool           Pool            @relation(fields: [poolAddress], references: [address])
  OrderExecution OrderExecution?
}

model OrderExecution {
  id        Int    @id @default(autoincrement())
  amountIn  String
  amountOut String
  thread    Int
  period    Int
  orderId   Int    @unique
  blockId   String
  Order     Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Maker {
  address        String
  date           DateTime
  poolAddress    String
  volume         Float
  accruedFeesX   String
  accruedFeesY   String
  accruedFeesL   String
  accruedFeesUsd Float

  @@id([address, poolAddress, date])
}

model RewardPool {
  poolAddress        String
  epoch              Int
  rewardTokenAddress String
  amount             String
  rewardToken        Token  @relation(fields: [rewardTokenAddress], references: [address])
  pool               Pool   @relation(fields: [poolAddress], references: [address], onDelete: Cascade)

  @@id([poolAddress, epoch])
}

model Bin {
  date        DateTime
  binId       Int
  poolAddress String
  volumeUsd   Float
  feesUsd     Float

  @@id([poolAddress, binId, date])
}

model Leaderboard {
  userAddress   String  @unique
  discordId     String? @unique
  zealySprintId Int
  score         Float

  @@id([zealySprintId, userAddress])
}

enum Status {
  ACTIVE
  STOPPED
  ENDED
}
